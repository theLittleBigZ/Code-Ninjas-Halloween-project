<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Photo Booth Registration</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <canvas id="bg-canvas" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:-1;"></canvas>
  <div style="position:relative;z-index:1;">
    <h1>Photo Booth Registration</h1>
    <form id="registration-form">
      <!-- TODO: Add form fields for parent/guardian info, child info, etc. -->
      <!-- Example: -->
      <label>First Name: <input type="text" name="firstName" required></label><br>
      <label>Last Name: <input type="text" name="lastName" required></label><br>
      <label>Email Address: <input type="text" name="emailAddress" required></label><br>
      <label>Phone Number: <input type="tel" name="phoneNumber" required></label><br>
      <label>How many pictures are being taken?: <input type="number" name="pictureAmount" pattern=(0-9)-(0-9)-(0-9) required></label><br>
      <!-- Add more fields as needed -->
      <button type="submit">Register</button>
    </form>
    <div id="registration-result"></div>
  </div>
  <script src="script.js"></script>
  <script>
    // Canvas animation for city, black hole, and flying objects with bulge and chromatic effects
    const canvas = document.getElementById('bg-canvas');
    const ctx = canvas.getContext('2d');
    // Offscreen canvas for drawing scene
    const offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d');
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      offCanvas.width = window.innerWidth;
      offCanvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Black hole position (center right)
    const blackHole = {
      x: () => canvas.width * 0.75,
      y: () => canvas.height * 0.5,
      r: 70
    };

    // Generate city buildings
    function genBuildings() {
      const buildings = [];
      const baseY = canvas.height * 0.7;
      for (let i = 0; i < 12; i++) {
        const w = 40 + Math.random() * 40;
        const h = 80 + Math.random() * 120;
        const x = i * (canvas.width / 12) + Math.random() * 20;
        buildings.push({x, y: baseY - h, w, h, color: `#${Math.floor(Math.random()*888+111)}88`});
      }
      return buildings;
    }
    let buildings = genBuildings();

    // Flying objects (cars, trucks, buildings)
    function genObject() {
      const types = ['car','truck','building'];
      const t = types[Math.floor(Math.random()*types.length)];
      let w, h, color;
      if (t==='car') { w=40; h=20; color='#e74c3c'; }
      else if (t==='truck') { w=60; h=25; color='#2980b9'; }
      else { w=40+Math.random()*40; h=60+Math.random()*60; color='#888'; }
      // Start from left or bottom
      let side = Math.random()<0.5?'left':'bottom';
      let x = side==='left'? -w : Math.random()*canvas.width*0.7;
      let y = side==='left'? canvas.height*0.7+Math.random()*canvas.height*0.3 : canvas.height+h;
      return {x, y, w, h, color, t, vx:0, vy:0};
    }
    let objects = [];
    for (let i=0;i<8;i++) objects.push(genObject());

    function drawBlackHole(ctx2) {
      ctx2.save();
      ctx2.beginPath();
      ctx2.arc(blackHole.x(), blackHole.y(), blackHole.r, 0, 2*Math.PI);
      ctx2.fillStyle = 'black';
      ctx2.shadowColor = '#444';
      ctx2.shadowBlur = 40;
      ctx2.fill();
      ctx2.restore();
      // Accretion disk
      ctx2.save();
      ctx2.beginPath();
      ctx2.arc(blackHole.x(), blackHole.y(), blackHole.r+18, 0, 2*Math.PI);
      ctx2.strokeStyle = 'rgba(255,255,200,0.5)';
      ctx2.lineWidth = 12;
      ctx2.shadowColor = 'yellow';
      ctx2.shadowBlur = 20;
      ctx2.stroke();
      ctx2.restore();
    }

    function drawStreet(ctx2) {
      ctx2.save();
      ctx2.fillStyle = '#444';
      ctx2.fillRect(0, canvas.height*0.7, canvas.width, canvas.height*0.3);
      ctx2.strokeStyle = '#fff';
      ctx2.lineWidth = 4;
      for (let i=0;i<canvas.width;i+=60) {
        ctx2.beginPath();
        ctx2.moveTo(i, canvas.height*0.85);
        ctx2.lineTo(i+30, canvas.height*0.85);
        ctx2.stroke();
      }
      ctx2.restore();
    }

    function drawBuildings(ctx2) {
      for (const b of buildings) {
        ctx2.save();
        ctx2.fillStyle = b.color;
        ctx2.fillRect(b.x, b.y, b.w, b.h);
        ctx2.restore();
      }
    }

    function drawObjects(ctx2) {
      for (const o of objects) {
        ctx2.save();
        ctx2.fillStyle = o.color;
        if (o.t==='car' || o.t==='truck') {
          ctx2.fillRect(o.x, o.y, o.w, o.h);
          ctx2.beginPath();
          ctx2.arc(o.x+o.w*0.2, o.y+o.h, 5, 0, 2*Math.PI);
          ctx2.arc(o.x+o.w*0.8, o.y+o.h, 5, 0, 2*Math.PI);
          ctx2.fillStyle = '#222';
          ctx2.fill();
        } else {
          ctx2.fillRect(o.x, o.y, o.w, o.h);
        }
        ctx2.restore();
      }
    }

    function updateObjects() {
      for (const o of objects) {
        let dx = blackHole.x() - (o.x+o.w/2);
        let dy = blackHole.y() - (o.y+o.h/2);
        let dist = Math.sqrt(dx*dx+dy*dy);
        let speed = 2 + 6*(1-Math.min(dist/1000,1));
        o.vx = dx/dist*speed;
        o.vy = dy/dist*speed;
        o.x += o.vx;
        o.y += o.vy;
      }
      for (let i=objects.length-1;i>=0;i--) {
        let o = objects[i];
        let cx = o.x+o.w/2, cy = o.y+o.h/2;
        let d = Math.sqrt((cx-blackHole.x())**2+(cy-blackHole.y())**2);
        if (d < blackHole.r+10) {
          objects.splice(i,1);
          objects.push(genObject());
        }
      }
    }

    // Bulge and chromatic effect
    function bulgeAndChromatic(srcCtx, destCtx) {
      const w = canvas.width, h = canvas.height;
      const src = srcCtx.getImageData(0,0,w,h);
      const dest = destCtx.createImageData(w,h);
      const cx = blackHole.x(), cy = blackHole.y(), r = blackHole.r*2.2;
      for (let y=0; y<h; y++) {
        for (let x=0; x<w; x++) {
          let dx = x-cx, dy = y-cy;
          let dist = Math.sqrt(dx*dx+dy*dy);
          let angle = Math.atan2(dy,dx);
          let bulge = 1;
          if (dist < r) {
            // Bulge: push pixels away from center, more near the event horizon
            let f = 1 + 0.45*Math.pow(1-(dist/r),2);
            bulge = f;
          }
          // Chromatic: offset RGB channels differently
          let idx = (y*w+x)*4;
          let getColor = (chOfs) => {
            let rx = Math.round(cx + (dx*bulge) + chOfs*Math.cos(angle+0.2));
            let ry = Math.round(cy + (dy*bulge) + chOfs*Math.sin(angle+0.2));
            if (rx<0||rx>=w||ry<0||ry>=h) return 0;
            let i2 = (ry*w+rx)*4;
            return src.data[i2];
          };
          dest.data[idx+0] = getColor(4); // R
          dest.data[idx+1] = getColor(-4); // G
          dest.data[idx+2] = getColor(0); // B
          dest.data[idx+3] = src.data[idx+3];
        }
      }
      destCtx.putImageData(dest,0,0);
    }

    function animate() {
      offCtx.clearRect(0,0,canvas.width,canvas.height);
      drawStreet(offCtx);
      drawBuildings(offCtx);
      drawBlackHole(offCtx);
      drawObjects(offCtx);
      updateObjects();
      // Bulge and chromatic effect
      bulgeAndChromatic(offCtx, ctx);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
