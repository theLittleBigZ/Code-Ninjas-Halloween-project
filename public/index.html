<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Photo Booth Registration</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <canvas id="bg-canvas" style="position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:-1;"></canvas>
  <div style="position:relative;z-index:1;">
    <h1>Photo Booth Registration</h1>
    <form id="registration-form">
      <!-- TODO: Add form fields for parent/guardian info, child info, etc. -->
      <!-- Example: -->
      <label>First Name: <input type="text" name="firstName" required></label><br>
      <label>Last Name: <input type="text" name="lastName" required></label><br>
      <label>Email Address: <input type="text" name="emailAddress" required></label><br>
      <label>Phone Number: <input type="tel" name="phoneNumber" required></label><br>
      <label>How many pictures are being taken?: <input type="number" name="pictureAmount" pattern=(0-9)-(0-9)-(0-9) required></label><br>
      <!-- Add more fields as needed -->
      <button type="submit">Register</button>
    </form>
    <div id="registration-result"></div>
  </div>
  <script src="script.js"></script>
  <script>
    // Canvas animation for city, black hole, and flying objects with bulge and chromatic effects
    const canvas = document.getElementById('bg-canvas');
    const ctx = canvas.getContext('2d');
    // Offscreen canvas for drawing scene
    const offCanvas = document.createElement('canvas');
    const offCtx = offCanvas.getContext('2d');
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      offCanvas.width = window.innerWidth;
      offCanvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Black hole position (center)
    const blackHole = {
      x: () => canvas.width * 0.5,
      y: () => canvas.height * 0.5,
      r: 90
    };

    // Generate city buildings
    // 3D perspective for buildings
    function genBuildings() {
      const buildings = [];
      const baseY = canvas.height * 0.7;
      for (let i = 0; i < 12; i++) {
        const w = 40 + Math.random() * 40;
        const h = 80 + Math.random() * 120;
        const x = i * (canvas.width / 12) + Math.random() * 20;
        // z for 3D effect (0=close, 1=far)
        const z = 0.2 + 0.8 * Math.random();
        buildings.push({x, y: baseY - h, w, h, color: `#${Math.floor(Math.random()*888+111)}88`, z});
      }
      return buildings;
    }
    let buildings = genBuildings();

    // Flying objects (cars, trucks, buildings)
    // 3D perspective for flying objects
    function genObject() {
      const types = ['car','truck','building'];
      const t = types[Math.floor(Math.random()*types.length)];
      let w, h, color;
      if (t==='car') { w=40; h=20; color='#e74c3c'; }
      else if (t==='truck') { w=60; h=25; color='#2980b9'; }
      else { w=40+Math.random()*40; h=60+Math.random()*60; color='#888'; }
      // z for 3D effect (0=close, 1=far)
      let z = 0.2 + 0.8 * Math.random();
      // Start from random edge
      let angle = Math.random() * 2 * Math.PI;
      let dist = Math.max(canvas.width, canvas.height) * (0.5 + 0.5 * Math.random());
      let x = blackHole.x() + Math.cos(angle) * dist;
      let y = blackHole.y() + Math.sin(angle) * dist;
      return {x, y, w, h, color, t, vx:0, vy:0, z};
    }
    let objects = [];
    for (let i=0;i<8;i++) objects.push(genObject());

    function drawBlackHole(ctx2) {
      ctx2.save();
      ctx2.beginPath();
      ctx2.arc(blackHole.x(), blackHole.y(), blackHole.r, 0, 2*Math.PI);
      ctx2.fillStyle = 'black';
      ctx2.shadowColor = '#444';
      ctx2.shadowBlur = 40;
      ctx2.fill();
      ctx2.restore();
      // Accretion disk
      ctx2.save();
      ctx2.beginPath();
      ctx2.arc(blackHole.x(), blackHole.y(), blackHole.r+18, 0, 2*Math.PI);
      ctx2.strokeStyle = 'rgba(255,255,200,0.5)';
      ctx2.lineWidth = 12;
      ctx2.shadowColor = 'yellow';
      ctx2.shadowBlur = 20;
      ctx2.stroke();
      ctx2.restore();
    }

    // 3D street with perspective
    function drawStreet(ctx2) {
      ctx2.save();
      // Draw street as a trapezoid for 3D effect
      let roadWTop = canvas.width * 0.18;
      let roadWBot = canvas.width * 0.7;
      let roadYTop = canvas.height * 0.45;
      let roadYBot = canvas.height * 0.95;
      ctx2.beginPath();
      ctx2.moveTo(canvas.width/2 - roadWTop/2, roadYTop);
      ctx2.lineTo(canvas.width/2 + roadWTop/2, roadYTop);
      ctx2.lineTo(canvas.width/2 + roadWBot/2, roadYBot);
      ctx2.lineTo(canvas.width/2 - roadWBot/2, roadYBot);
      ctx2.closePath();
      ctx2.fillStyle = '#444';
      ctx2.fill();
      // Lane lines (perspective)
      ctx2.strokeStyle = '#fff';
      ctx2.lineWidth = 4;
      for (let i=0;i<8;i++) {
        let t = i/8;
        let x1 = canvas.width/2 - (roadWTop/2)*(1-t) - (roadWBot/2)*t;
        let x2 = canvas.width/2 + (roadWTop/2)*(1-t) + (roadWBot/2)*t;
        let y = roadYTop*(1-t) + roadYBot*t;
        ctx2.beginPath();
        ctx2.moveTo(x1+20, y);
        ctx2.lineTo(x2-20, y);
        ctx2.stroke();
      }
      ctx2.restore();
    }

    // 3D buildings with perspective
    function drawBuildings(ctx2) {
      for (const b of buildings) {
        ctx2.save();
        // Perspective scaling
        let scale = 0.5 + 1.2 * (1-b.z);
        let bx = (b.x-canvas.width/2)*scale + canvas.width/2;
        let by = (b.y-canvas.height*0.7)*scale + canvas.height*0.7;
        ctx2.fillStyle = b.color;
        ctx2.fillRect(bx, by, b.w*scale, b.h*scale);
        ctx2.restore();
      }
    }

    // 3D objects with perspective
    function drawObjects(ctx2) {
      for (const o of objects) {
        ctx2.save();
        // Perspective scaling based on distance to black hole
        let dx = o.x - blackHole.x();
        let dy = o.y - blackHole.y();
        let dist = Math.sqrt(dx*dx+dy*dy);
        let maxDist = Math.max(canvas.width, canvas.height)*0.6;
        let scale = 0.25 + 1.2 * Math.min(dist/maxDist,1);
        let ox = (o.x-canvas.width/2)*scale + canvas.width/2;
        let oy = (o.y-canvas.height/2)*scale + canvas.height/2;
        ctx2.fillStyle = o.color;
        if (o.t==='car' || o.t==='truck') {
          ctx2.fillRect(ox, oy, o.w*scale, o.h*scale);
          ctx2.beginPath();
          ctx2.arc(ox+o.w*scale*0.2, oy+o.h*scale, 5*scale, 0, 2*Math.PI);
          ctx2.arc(ox+o.w*scale*0.8, oy+o.h*scale, 5*scale, 0, 2*Math.PI);
          ctx2.fillStyle = '#222';
          ctx2.fill();
        } else {
          ctx2.fillRect(ox, oy, o.w*scale, o.h*scale);
        }
        ctx2.restore();
      }
    }

    function updateObjects() {
      for (const o of objects) {
        let dx = blackHole.x() - o.x;
        let dy = blackHole.y() - o.y;
        let dist = Math.sqrt(dx*dx+dy*dy);
        let speed = 2 + 6*(1-Math.min(dist/1000,1));
        o.vx = dx/dist*speed;
        o.vy = dy/dist*speed;
        o.x += o.vx;
        o.y += o.vy;
      }
      for (let i=objects.length-1;i>=0;i--) {
        let o = objects[i];
        let d = Math.sqrt((o.x-blackHole.x())**2+(o.y-blackHole.y())**2);
        if (d < blackHole.r+10) {
          objects.splice(i,1);
          objects.push(genObject());
        }
      }
    }

    // Bulge and chromatic effect
    function bulgeAndChromatic(srcCtx, destCtx) {
      const w = canvas.width, h = canvas.height;
      const src = srcCtx.getImageData(0,0,w,h);
      const dest = destCtx.createImageData(w,h);
      const cx = blackHole.x(), cy = blackHole.y(), r = blackHole.r*2.2;
      for (let y=0; y<h; y++) {
        for (let x=0; x<w; x++) {
          let dx = x-cx, dy = y-cy;
          let dist = Math.sqrt(dx*dx+dy*dy);
          let angle = Math.atan2(dy,dx);
          let bulge = 1;
          if (dist < r) {
            // Bulge: push pixels away from center, more near the event horizon
            let f = 1 + 0.45*Math.pow(1-(dist/r),2);
            bulge = f;
          }
          // Chromatic: offset RGB channels differently
          let idx = (y*w+x)*4;
          let getColor = (chOfs) => {
            let rx = Math.round(cx + (dx*bulge) + chOfs*Math.cos(angle+0.2));
            let ry = Math.round(cy + (dy*bulge) + chOfs*Math.sin(angle+0.2));
            if (rx<0||rx>=w||ry<0||ry>=h) return 0;
            let i2 = (ry*w+rx)*4;
            return src.data[i2];
          };
          dest.data[idx+0] = getColor(4); // R
          dest.data[idx+1] = getColor(-4); // G
          dest.data[idx+2] = getColor(0); // B
          dest.data[idx+3] = src.data[idx+3];
        }
      }
      destCtx.putImageData(dest,0,0);
    }

    function animate() {
      offCtx.clearRect(0,0,canvas.width,canvas.height);
      drawStreet(offCtx);
      drawBuildings(offCtx);
      drawBlackHole(offCtx);
      drawObjects(offCtx);
      updateObjects();
      // Bulge and chromatic effect
      bulgeAndChromatic(offCtx, ctx);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
